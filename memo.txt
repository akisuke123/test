終了
Space q q
再起動
Space q r
デバッグモードで再起動
Space q d

Ctrl-h でバックスペースにする　　.emacs.dの init.elに以下を追加
(keyboard-translate ?\C-h ?\C-?)

ウィンドウの大きさ変更 .spacemacsに以下を追加
(add-to-list 'default-frame-alist '(height . 60))
(add-to-list 'default-frame-alist '(width . 220)) 



■HELP Space h
Space h k Keyを調べる
Space ?  キーバインドを調べる
Space h d 調べる系
Space h d b キーバインドを調べるSpace？と同じかな
Space h d f 関数を調べる
Space h d m 現在のバッファで有効になっているモードと使えるキーバインドを調べる
Space h d p パッケージを調べる
Space h d s システム情報をクリップボードにコピー(messageバッファで確認できる)
Space h d v 変数を調べる

■ウィンドウ操作 Space w
Space w TAB		別のウィンドウを移動
Space w 2,3		縦に{2,3}分割
Space w f		follow-modeの切り替え
Space w b		ミニバッファに移動
Space w d		ウィンドウを消去
Space w h,j,k,l		上下左右に移動
Space w W		移動するウィンドウを選択
Space w D		消去するウィンドウを選択
Space w M		スワップするウィンドウを選択
Space 数字 Windowの移動

■バッファ操作 Space b
Space b .		バッファ移動ステート
Space b b		バッファを選択
Space b s		*scratch*バッファ
Space b d		バッファを削除
Space b h		Spacemacsのホーム画面

■ファイル操作 Space f
Space f f		ファイルを開く
Space f r		最近使ったファイルを開く
Space f j		ディレクトリを開く
Space f J		仮ファイルを開く

■Spacemacsの設定 Space f e
Space f e		Spacemacsレイヤーの操作
Space f e d		~/.spacemacsを開く
Space f e i		~/.emacs.d/init.elを開く
Space f e R		設定ファイルを再読込み

■Git操作 Space g
Space g s   Magitを起動

ディレクトリツリーを表示
Space f t
f file
t tree

h  上の階層に移動
l　下の階層に移動
s  隠しファイル表示


ディレクトリツリーで新規作成
ファイル作成
c f
ディレクトリ作成
c d

.spacemacsファイルを開く
Space f e d

設定ファイルの反映
Space f e R

Command実行
Space !

日本語
Ctrl-\

■Clojure
.cljファイルを開いた状態で
REPL
start
Space m s i
end
Space m s q

起動済みREPL
Space m s c

calc
(+ 2 4)

Ctrl-k 前回の履歴戻る
Ctrl-j 進む

変数代入
(def x 10)

関数定義
(defn func []
  (println "functest"))

(defn func [a b c]
  (+ a b c))
  
戻り値は最後の式になる。

引数の数の違いで関数を分けられる
(defn piyo
  ([] println "one")
  ([x] println "two")
  ([x y] println "three"))

可変引数
(defn fuga [& args]
  (println args))

defn は関数名をつけて後から呼び出せる仕組み
無名関数はfnで定義する

((fn [a b c] (+ a b c)) 1 2 3 )
((fn [message] (println message)) "hello world")

無名変数を変数に束縛する
(def x (fn [y] (+ y 3)))
と
(defn x [y] (+ y 3))
は同じ

fnマクロには簡略的な書き方ができる
(fn [a b c] (* a b c))
は
#(* %1 %2 %3)
と同じ（引数が一つの場合は%だけ）
(filter #(even? %) [1 2 3 4])

letを使うと狭い範囲の変数束縛ができる
(let [x 3 y 4] (println x y))

(def x 3)
(def y 4)
(println x y)
だとx,yはコード実行後も変数束縛されている

関数内で使うときなどによく使う
(defn triangle [x y] 
  (let [temp (* x y)] (/ temp 2)))

変数を区別するためにネームスペースを使用する
たいていの場合はファイルの１行目にnsを使ってこのファイルのネームスペースを宣言する
(ns abc.core)
(def cons-point [x y]
  {:x x :y y})

の場合、abc.coreのネームスペースが作成され、これ以降に続く変数、関数はabc.coreのネームスペースに所属することになる。

ネームスペースを作る際に、別のネームスペースを利用する宣言も同時に可能
(ns abc.core
  (:require [clojure.edn :as edn]))
clojure.ednという名前のネームスペースを ednという名前で利用できるようにしている
clojure.ednネームスペースにはreadという関数が用意されているので:requireで上記のように指定された場合、read関数は
edn/read で呼び出せるようになる

複数のrequire可能
(ns abc.core
  (:require [clojure.edn :as edn] [clojure.string :as cstring]))

:useを使うとネームスペース内の関数や変数を利用できるようになる
(ns abc.core
 (:use [clojure.edn]))
read で使えるようになる

nsを使わずにrequire use を使うときは ' をつける
(use 'cloure.string)
(require '[clojure.edn :as edn])
※基本的にはuseは使わなくなったらしい Clojure1.4以降では

コメント
; ここから行末までコメント
(comment "この中がコメント")
(comment (println "式もコメントになるが、正しくないとエラーになる"))
#_(list 1 2 3) ;これもコメント

四則演算
加算
(+ 1 2)   3
(+ 1.0 2.0 3.0) 6.0
減算
(-12 5)   7
(-5 3 2)  0
乗算
(* 1 2 3)  6
除算
(/ 2 3)  2/3
(/ 10.0 2.5)  4.0
